(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{343:function(v,_,a){"use strict";a.r(_);var s=a(8),t=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("div",{staticClass:"custom-block warning"},[_("p",{staticClass:"custom-block-title"},[v._v("注意")]),v._v(" "),_("p",[v._v("本文由ChatGPT生成，请自行甄别。")])]),v._v(" "),_("p",[v._v("如果你生成的是 "),_("strong",[v._v("静态库")]),v._v("，那么生成的文件会是 "),_("code",[v._v(".a")]),v._v(" 文件（在 MinGW 中）或 "),_("code",[v._v(".lib")]),v._v(" 文件（在 MSVC 中）。静态库与动态库不同，不会生成 "),_("code",[v._v(".dll.a")]),v._v(" 这样的导入库。静态库的本质和使用方式如下：")]),v._v(" "),_("h3",{attrs:{id:"静态库的特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#静态库的特点"}},[v._v("#")]),v._v(" 静态库的特点：")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("直接包含代码")]),v._v("：静态库（"),_("code",[v._v(".a")]),v._v(" 或 "),_("code",[v._v(".lib")]),v._v("）包含了库的所有实现代码。在编译和链接阶段，链接器会将所需的库代码嵌入到最终的可执行文件中。因此，编译后生成的 "),_("code",[v._v(".exe")]),v._v(" 是一个独立的文件，运行时不再需要外部的动态库。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("不依赖运行时的 "),_("code",[v._v(".dll")]),v._v(" 文件")]),v._v("：当你链接到静态库时，程序在运行时不会依赖动态库（"),_("code",[v._v(".dll")]),v._v(" 文件），因为所有的依赖代码都已经在编译时被嵌入到可执行文件中。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("不会生成导入库")]),v._v("：静态库没有所谓的导入库（"),_("code",[v._v(".dll.a")]),v._v(" 或 "),_("code",[v._v(".lib")]),v._v("），因为静态库本身就是编译和链接的直接目标。所有符号解析和代码引用都发生在编译时。")])])]),v._v(" "),_("h3",{attrs:{id:"静态库生成过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#静态库生成过程"}},[v._v("#")]),v._v(" 静态库生成过程：")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("MinGW（或其他 GCC 系工具链）")]),v._v("：使用 "),_("code",[v._v("ar")]),v._v(" 工具来创建静态库，生成 "),_("code",[v._v(".a")]),v._v(" 文件。通常，静态库文件命名为 "),_("code",[v._v("libname.a")]),v._v("，比如 "),_("code",[v._v("libprotobuf.a")]),v._v("。")]),v._v(" "),_("p",[v._v("示例命令：")]),v._v(" "),_("div",{staticClass:"language-bash line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[v._v("gcc "),_("span",{pre:!0,attrs:{class:"token parameter variable"}},[v._v("-c")]),v._v(" mylib.c "),_("span",{pre:!0,attrs:{class:"token parameter variable"}},[v._v("-o")]),v._v(" mylib.o   "),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 生成目标文件")]),v._v("\nar rcs libmylib.a mylib.o   "),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 生成静态库文件")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("MSVC（Visual Studio）")]),v._v("：使用 "),_("code",[v._v("LIB")]),v._v(" 工具生成静态库，生成 "),_("code",[v._v(".lib")]),v._v(" 文件。MSVC 环境下，静态库的文件后缀通常是 "),_("code",[v._v(".lib")]),v._v("。")])])]),v._v(" "),_("h3",{attrs:{id:"使用静态库"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用静态库"}},[v._v("#")]),v._v(" 使用静态库：")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("链接静态库")]),v._v("：在使用静态库时，你的编译命令或构建系统会链接到 "),_("code",[v._v(".a")]),v._v(" 或 "),_("code",[v._v(".lib")]),v._v(" 文件。比如在 CMake 中，链接静态库通常使用 "),_("code",[v._v("target_link_libraries()")]),v._v(" 指向静态库路径：")]),v._v(" "),_("div",{staticClass:"language-cmake line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-cmake"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("target_link_libraries")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("my_executable "),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"path_to_lib/libprotobuf.a"')]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("编译时嵌入库代码")]),v._v("：在编译可执行文件时，链接器会将静态库中的所有必要代码嵌入到可执行文件中，生成的 "),_("code",[v._v(".exe")]),v._v(" 文件会包含所有依赖，因此不需要额外的 "),_("code",[v._v(".dll")]),v._v(" 文件。")])])]),v._v(" "),_("h3",{attrs:{id:"生成静态库时注意"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#生成静态库时注意"}},[v._v("#")]),v._v(" 生成静态库时注意：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("静态库的好处是部署方便，执行时不需要额外的库文件，但也有缺点：所有使用静态库的可执行文件都包含重复的库代码，可能导致文件体积变大。")])]),v._v(" "),_("li",[_("p",[v._v("如果你希望在发布程序时不依赖动态库，生成和链接静态库是个不错的选择，但如果多个程序共享库，动态库可能更节省内存和磁盘空间。")])])]),v._v(" "),_("h3",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("静态库")]),v._v("（"),_("code",[v._v(".a")]),v._v(" 或 "),_("code",[v._v(".lib")]),v._v("）包含完整的库实现，编译时嵌入到最终的可执行文件中，不会生成 "),_("code",[v._v(".dll.a")]),v._v(" 或 "),_("code",[v._v(".lib")]),v._v(" 作为导入库。")]),v._v(" "),_("li",[v._v("静态库链接后，程序在运行时不需要任何 "),_("code",[v._v(".dll")]),v._v(" 文件。")]),v._v(" "),_("li",[v._v("静态库的优点是独立性，缺点是文件体积会较大。")])]),v._v(" "),_("p",[v._v("如果你在生成的是静态库，只需要 "),_("code",[v._v(".a")]),v._v("（或 "),_("code",[v._v(".lib")]),v._v("），不会生成 "),_("code",[v._v(".dll.a")]),v._v(" 这样的导入库。")])])}),[],!1,null,null,null);_.default=t.exports}}]);